# AI Revenue Guardian: Implementation & Testing Plan

## 1. Executive Summary

This document details the implementation and testing strategy for the "AI Revenue Guardian" module (Module 16-C). This module leverages predictive analytics to provide academy owners with actionable financial insights. Its primary functions are to identify players at high risk of churning and to generate a 90-day cash flow forecast.

The plan outlines the core domain entity for storing risk analysis, the backend job responsible for the predictive calculations, a frontend widget for visualizing risk, and a testing strategy to validate the accuracy of the risk-scoring algorithm.

## 2. Architectural Blueprint: Domain Entity

The core of the churn prediction feature is a new entity designed to store the calculated risk score for each player. This data is refreshed by a nightly background job.

**Action:** Create the `PlayerChurnRisk` entity in the `Diquis.Domain` project.

**File:** `Diquis.Domain/Entities/PlayerChurnRisk.cs`
```csharp
namespace Diquis.Domain.Entities;

/// <summary>
/// Represents the calculated churn risk for a single player,
/// updated via a recurring background job.
/// </summary>
public class PlayerChurnRisk : BaseEntity, IMustHaveTenant
{
    public Guid PlayerId { get; set; }
    public RiskScore RiskScore { get; set; }

    /// <summary>
    /// JSON array storing the signals that triggered the risk flag.
    /// e.g., ["AttendanceSignal", "FinancialSignal"]
    /// </summary>
    public required string TriggeringSignals { get; set; }
    
    public DateTime LastCalculatedUtc { get; set; }
    public required string TenantId { get; set; }
}

public enum RiskScore { High, Medium }
```

## 3. Backend Implementation: Churn Prediction Job

The churn risk calculation is not a real-time process. It will be handled by a recurring background job (e.g., using Hangfire) that runs nightly. This job is responsible for analyzing multiple data signals for each player and aggregating them into a final risk score.

**Action:** Implement the `ChurnPredictionJob` with its core signal aggregation logic.

**File:** `Diquis.Infrastructure/BackgroundJobs/ChurnPredictionJob.cs` (Illustrative Logic)
```csharp
// This class will be registered with a recurring job runner like Hangfire.
public class ChurnPredictionJob
{
    // Inject DbContext and any necessary analysis services.
    
    public async Task Execute(string tenantId)
    {
        // This job is invoked once per tenant.
        var activePlayers = await _context.Users
            .Where(u => u.TenantId == tenantId && u.IsActive && u.Role == "Player")
            .ToListAsync();
        
        var newRiskResults = new List<PlayerChurnRisk>();

        foreach (var player in activePlayers)
        {
            var signals = new List<string>();

            // 1. Attendance Signal (from Module 4)
            bool hasLowAttendance = await _analyticsService.CheckLowAttendanceAsync(player.Id, 30, 0.50);
            if (hasLowAttendance) signals.Add("AttendanceSignal");

            // 2. Financial Signal (from Module 1)
            bool hasOverdueInvoice = await _financialService.CheckOverdueInvoicesAsync(player.FamilyId, 5);
            if (hasOverdueInvoice) signals.Add("FinancialSignal");
            
            // 3. Engagement Signal (from User Logs)
            bool hasLowParentEngagement = await _identityService.CheckParentLoginDateAsync(player.FamilyId, 60);
            if (hasLowParentEngagement) signals.Add("EngagementSignal");

            if (signals.Any())
            {
                newRiskResults.Add(new PlayerChurnRisk
                {
                    PlayerId = player.Id,
                    RiskScore = (signals.Count >= 2) ? RiskScore.High : RiskScore.Medium,
                    TriggeringSignals = System.Text.Json.JsonSerializer.Serialize(signals),
                    LastCalculatedUtc = DateTime.UtcNow,
                    TenantId = tenantId
                });
            }
        }
        
        // Atomically update the risk records for the current tenant.
        await _context.PlayerChurnRisks.Where(r => r.TenantId == tenantId).ExecuteDeleteAsync();
        await _context.PlayerChurnRisks.AddRangeAsync(newRiskResults);
        await _context.SaveChangesAsync();
    }
}
```

## 4. Frontend Implementation (React)

A new feature folder will be created to house the UI for the Revenue Guardian module. The primary component will be a dashboard widget that displays players at risk of churning.

### 4.1. Folder Structure

**Action:** Create the new feature folder `src/features/ai-revenue`.

### 4.2. Risk Indicator Widget

This component will fetch the data generated by the backend job and display it using clear visual cues, as requested. "Traffic light" badges will be used to represent the risk levels.

**Action:** Implement the `PlayersAtRiskWidget` component.

**File:** `src/features/ai-revenue/components/PlayersAtRiskWidget.tsx`
```tsx
import React, { useEffect, useState } from 'react';
import { Badge, ListGroup, Spinner } from 'react-bootstrap';

// Style mapping for the traffic light badges
const riskStyles = {
  High: { bg: 'danger', text: 'High' },
  Medium: { bg: 'warning', text: 'Medium' },
};

const RiskBadge = ({ score }) => {
  const style = riskStyles[score] || { bg: 'secondary', text: 'Unknown' };
  return <Badge bg={style.bg}>{style.text}</Badge>;
};

export const PlayersAtRiskWidget = () => {
  const [players, setPlayers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // In a real app, this would be an API call to GET /api/predictive-analytics/players-at-risk
    const fetchPlayersAtRisk = async () => {
      setIsLoading(true);
      // Mock data for demonstration
      const mockData = [
        { playerId: '1', playerName: 'Alice Smith', riskScore: 'High', signals: ['AttendanceSignal', 'FinancialSignal'] },
        { playerId: '2', playerName: 'Bob Johnson', riskScore: 'Medium', signals: ['AttendanceSignal'] },
      ];
      setPlayers(mockData);
      setIsLoading(false);
    };
    fetchPlayersAtRisk();
  }, []);

  if (isLoading) return <Spinner animation="border" />;

  return (
    <ListGroup>
      {players.map(player => (
        <ListGroup.Item key={player.playerId} className="d-flex justify-content-between align-items-center">
          <div>
            <strong>{player.playerName}</strong>
            <small className="d-block text-muted">Triggers: {player.signals.join(', ')}</small>
          </div>
          <RiskBadge score={player.riskScore} />
        </ListGroup.Item>
      ))}
    </ListGroup>
  );
};
```

## 5. Testing Strategy

The testing strategy must focus on verifying the core of the predictive model: the risk calculation algorithm within the `ChurnPredictionJob`. This can be achieved with a backend unit test that mocks the various data signals.

### 5.1. Backend Unit Test: Risk Calculation Algorithm

This test will validate that the aggregation logic correctly assigns `RiskScore` based on the number of active signals.

**Action:** Create a unit test file for the `ChurnPredictionJob`.

**File:** `Diquis.Infrastructure.Tests/BackgroundJobs/ChurnPredictionJobTests.cs` (Illustrative Test)
```csharp
using Moq;
using NUnit.Framework;
using System.Threading.Tasks;

[TestFixture]
public class ChurnPredictionJobTests
{
    private Mock<IAnalyticsService> _mockAnalytics;
    private Mock<IFinancialService> _mockFinancial;
    private Mock<IIdentityService> _mockIdentity;
    private ChurnPredictionJob _job;
    // Assume DbContext is mocked or an in-memory version is used

    [SetUp]
    public void Setup()
    {
        _mockAnalytics = new Mock<IAnalyticsService>();
        _mockFinancial = new Mock<IFinancialService>();
        _mockIdentity = new Mock<IIdentityService>();
        _job = new ChurnPredictionJob(/* inject mocks and context */);
    }

    [Test]
    public async Task Execute_PlayerWithOneStrongSignal_ShouldBeMediumRisk()
    {
        // Arrange: Player has only one negative signal (low attendance)
        _mockAnalytics.Setup(s => s.CheckLowAttendanceAsync(It.IsAny<Guid>(), 30, 0.50)).ReturnsAsync(true);
        _mockFinancial.Setup(s => s.CheckOverdueInvoicesAsync(It.IsAny<Guid>(), 5)).ReturnsAsync(false);
        _mockIdentity.Setup(s => s.CheckParentLoginDateAsync(It.IsAny<Guid>(), 60)).ReturnsAsync(false);

        // Act
        await _job.Execute("test-tenant-id");

        // Assert: Verify that a PlayerChurnRisk record was created with the correct score.
        // (Using a mock context or spy to capture the added entity)
        var capturedRisk = /* ... logic to get the created PlayerChurnRisk entity ... */;
        Assert.AreEqual(RiskScore.Medium, capturedRisk.RiskScore);
    }

    [Test]
    public async Task Execute_PlayerWithTwoSignals_ShouldBeHighRisk()
    {
        // Arrange: Player has two negative signals (low attendance and late payment)
        _mockAnalytics.Setup(s => s.CheckLowAttendanceAsync(It.IsAny<Guid>(), 30, 0.50)).ReturnsAsync(true);
        _mockFinancial.Setup(s => s.CheckOverdueInvoicesAsync(It.IsAny<Guid>(), 5)).ReturnsAsync(true);
        _mockIdentity.Setup(s => s.CheckParentLoginDateAsync(It.Isany<Guid>(), 60)).ReturnsAsync(false);

        // Act
        await _job.Execute("test-tenant-id");

        // Assert
        var capturedRisk = /* ... logic to get the created PlayerChurnRisk entity ... */;
        Assert.AreEqual(RiskScore.High, capturedRisk.RiskScore);
    }

    [Test]
    public async Task Execute_PlayerWithNoSignals_ShouldNotCreateRiskRecord()
    {
        // Arrange: Player has no negative signals
        _mockAnalytics.Setup(s => s.CheckLowAttendanceAsync(It.IsAny<Guid>(), 30, 0.50)).ReturnsAsync(false);
        // ... set up other mocks to return false ...

        // Act
        await _job.Execute("test-tenant-id");

        // Assert: Verify that NO PlayerChurnRisk record was created for this player.
        // (Check that the context's Add method was not called with a risk record for this player)
        Assert.IsEmpty(/* ... collection of captured risk records ... */);
    }
}
```
This test suite directly validates the core business logic of the churn prediction engine, ensuring its calculations are correct before the data is ever displayed to the user.
