# Communication & Notification Engine: Implementation & Testing Plan

## 1. Executive Summary

This document outlines the implementation and testing strategy for the Communication & Notification Engine. This module serves as a centralized, cross-cutting service responsible for intelligently routing alerts to users via their preferred channels (In-App, Push, Email).

The plan details the domain model for notifications, the frontend implementation of a real-time notification bell in the application's topbar, and a backend testing strategy focused on validating the critical routing logic that decides whether to send an alert immediately, digest it, or send it to multiple channels.

## 2. Architectural Blueprint: The `Notification` Entity

The core of the in-app notification system is the `Notification` entity, which represents a single alert for a user.

**Action:** Create the `Notification.cs` entity file in the `Diquis.Domain` project.

**File:** `Diquis.Domain/Entities/Notification.cs`
```csharp
using Diquis.Domain.Entities.Common;
using Diquis.Domain.Entities.Multitenancy;

namespace Diquis.Domain.Entities;

/// <summary>
/// Represents a single notification generated by the system for a specific user.
/// </summary>
public class Notification : BaseEntity, IMustHaveTenant
{
    public Guid UserId { get; set; }
    public ApplicationUser User { get; set; }

    public required string Message { get; set; }

    /// <summary>
    /// A client-side route to navigate to when the notification is clicked.
    /// E.g., "/injuries/b4a5-..."
    /// </summary>
    public string? DeepLink { get; set; }

    /// <summary>
    /// The type of event that triggered this notification, used for preference-based routing.
    /// E.g., "PlayerInjuryStatusChanged", "NewDocumentAwaitingSignature".
    /// </summary>
    public required string EventType { get; set; }

    public bool IsRead { get; set; } = false;

    public NotificationCriticality Criticality { get; set; } = NotificationCriticality.Informational;

    public required string TenantId { get; set; }
}

public enum NotificationCriticality { Informational, Warning, Critical }
```

## 3. Backend Implementation: "Smart" Routing Logic

The core of the backend is the `NotificationService`, which contains the "smart" routing logic to decide how and where to send an alert based on user preferences and event criticality.

**Action:** Implement the `SendNotificationAsync` method in `NotificationService.cs`. This method will be called by other services when an event occurs.

**File:** `Diquis.Application/Services/Notifications/NotificationService.cs` (enhancement)
```csharp
public class NotificationService : INotificationService
{
    private readonly ApplicationDbContext _context;
    private readonly IBackgroundJobService _jobService; // For enqueuing Email/Push jobs

    public async Task SendNotificationAsync(NotificationRequest request)
    {
        // Always create the in-app notification record first.
        var notification = new Notification { /* map from request */ };
        _context.Notifications.Add(notification);
        await _context.SaveChangesAsync();

        // Fetch user preferences and event criticality.
        var preferences = await _context.UserNotificationPreferences.FindAsync(request.UserId);
        var isCritical = request.Criticality == NotificationCriticality.Critical;
        
        // CRITICAL ROUTING LOGIC
        if (isCritical)
        {
            // For critical events, override preferences and send to all channels immediately.
            _jobService.Enqueue<IPushNotificationService>(s => s.SendPushAsync(request.UserId, request.Message));
            _jobService.Enqueue<IEmailService>(s => s.SendEmailAsync(request.UserId, "Critical Alert", request.Message));
            return;
        }

        var eventPrefs = preferences?.GetPreferencesForEvent(request.EventType);
        if (eventPrefs?.UseDailyDigest == true)
        {
            // User wants a digest, so we've saved the in-app notification and we're done.
            return;
        }

        // Send to user's preferred channels.
        if (eventPrefs?.Channels.Contains("Push") == true)
        {
            _jobService.Enqueue<IPushNotificationService>(s => s.SendPushAsync(request.UserId, request.Message));
        }
        if (eventPrefs?.Channels.Contains("Email") == true)
        {
            _jobService.Enqueue<IEmailService>(s => s.SendEmailAsync(request.UserId, "Notification", request.Message));
        }
    }
}
```

## 4. Frontend Implementation (React)

The frontend will be enhanced with a real-time notification center, accessible via a bell icon in the main topbar.

### 4.1. Folder Structure

**Action:** Create the new feature folder `src/features/notifications`.

### 4.2. Notification Bell & Dropdown

**Action:** Modify the main application layout to include the `NotificationBell` component. The bell will poll for new notifications.

**File:** `src/layouts/components/NotificationBell.tsx`
```tsx
import { useState, useEffect } from 'react';
import { Dropdown, Badge } from 'react-bootstrap';
import { useNotificationsApi } from '@/features/notifications/hooks/useNotificationsApi';
import { Link } from 'react-router-dom';

export const NotificationBell = () => {
  const [unreadCount, setUnreadCount] = useState(0);
  const [notifications, setNotifications] = useState([]);
  const { getUnreadCount, getRecentNotifications } = useNotificationsApi();

  // Poll for unread count every 30 seconds
  useEffect(() => {
    const fetchCount = () => getUnreadCount().then(setUnreadCount);
    fetchCount();
    const interval = setInterval(fetchCount, 30000);
    return () => clearInterval(interval);
  }, [getUnreadCount]);

  const onToggle = (isOpen) => {
    if (isOpen) {
      getRecentNotifications().then(setNotifications);
    }
  };

  return (
    <Dropdown onToggle={onToggle}>
      <Dropdown.Toggle variant="transparent" id="notification-bell" className="position-relative">
        <i className="bi bi-bell-fill fs-5"></i>
        {unreadCount > 0 && (
          <Badge pill bg="danger" className="position-absolute top-0 start-100 translate-middle">
            {unreadCount}
          </Badge>
        )}
      </Dropdown.Toggle>

      <Dropdown.Menu align="end" style={{ minWidth: '300px' }}>
        <Dropdown.Header>Notifications</Dropdown.Header>
        {notifications.length > 0 ? (
          notifications.map(n => (
            <Dropdown.Item as={Link} to={n.deepLink || '#'} key={n.id}>
              {n.message}
            </Dropdown.Item>
          ))
        ) : (
          <Dropdown.Item disabled>No new notifications</Dropdown.Item>
        )}
        <Dropdown.Divider />
        <Dropdown.Item as={Link} to="/notifications">View All</Dropdown.Item>
      </Dropdown.Menu>
    </Dropdown>
  );
};
```

## 5. Testing Strategy

The testing strategy will focus on the backend routing logic to ensure notifications are sent to the correct channels based on user preferences and criticality.

### 5.1. Backend Unit Test: Notification Routing Logic

This test will mock the background job service and user preferences to validate the decision-making process within the `NotificationService`.

**Action:** Create a unit test file in `Diquis.Application.Tests`.

**File:** `Diquis.Application.Tests/Notifications/NotificationRoutingTests.cs`
```csharp
using Moq;
using NUnit.Framework;
using System;
using System.Linq.Expressions;
using System.Threading.Tasks;

[TestFixture]
public class NotificationRoutingTests
{
    private NotificationService _service;
    private Mock<IBackgroundJobService> _mockJobService;
    private Mock<ApplicationDbContext> _mockContext;

    [SetUp]
    public void Setup()
    {
        _mockJobService = new Mock<IBackgroundJobService>();
        _mockContext = new Mock<ApplicationDbContext>();
        // ... setup DbSet mocks ...

        _service = new NotificationService(_mockContext.Object, _mockJobService.Object);
    }

    [Test]
    public async Task SendNotificationAsync_WhenEventIsCritical_ShouldEnqueuePushAndEmailJobs()
    {
        // Arrange
        var request = new NotificationRequest { Criticality = NotificationCriticality.Critical, /*...*/ };
        
        // Act
        await _service.SendNotificationAsync(request);

        // Assert
        // Verify push notification was enqueued
        _mockJobService.Verify(s => s.Enqueue<IPushNotificationService>(It.IsAny<Expression<Action<IPushNotificationService>>>()), Times.Once);
        // Verify email notification was enqueued
        _mockJobService.Verify(s => s.Enqueue<IEmailService>(It.IsAny<Expression<Action<IEmailService>>>()), Times.Once);
    }

    [Test]
    public async Task SendNotificationAsync_WhenUserPrefersDigest_ShouldNotEnqueueAnyJobs()
    {
        // Arrange
        var request = new NotificationRequest { EventType = "PlayerProfileUpdated", /*...*/ };
        var preferences = new UserNotificationPreference();
        // This is a simplified representation of setting a preference.
        // In a real scenario, you'd mock the JSON parsing and preference retrieval.
        // preferences.SetPreference("PlayerProfileUpdated", useDigest: true); 
        
        // Setup mock context to return these preferences for the user...

        // Act
        await _service.SendNotificationAsync(request);

        // Assert
        // Verify no jobs were enqueued because the user wants a digest
        _mockJobService.Verify(s => s.Enqueue<IPushNotificationService>(It.IsAny<Expression<Action<IPushNotificationService>>>()), Times.Never);
        _mockJobService.Verify(s => s.Enqueue<IEmailService>(It.IsAny<Expression<Action<IEmailService>>>()), Times.Never);
    }
}
```
This test suite provides high confidence that the core routing logic of the notification engine is functioning as designed, respecting both event criticality and user preferences.