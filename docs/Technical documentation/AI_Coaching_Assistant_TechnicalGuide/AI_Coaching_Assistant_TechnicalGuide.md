# Technical Implementation Guide: Module 16-B (AI Coaching Assistant)

This document provides a detailed technical guide for implementing the "Operational AI (The Assistant Coach)" module. This suite of tools is designed to assist coaching staff by automating administrative and creative tasks.

## 1. Architectural Analysis

### Domain Entities

This module introduces two new entities to store the AI-generated content, allowing for review, editing, and history tracking.

1.  **`TrainingSessionPlan`**: Represents an AI-generated plan for a single training session.
    *   `TeamId` (Guid, required, FK to `Team` entity).
    *   `GeneratedContent` (string, required, Markdown/Text format): The full, editable text of the generated plan.
    *   `FocusArea` (string): The primary focus supplied by the coach (e.g., "Defensive Transitions").
    *   `AiPromptContext` (JSON, string): A snapshot of the key data fed to the AI (e.g., `{ "teamAgeGroup": "U-14", "availableEquipment": { "Cones": 40, "Bibs": 20 } }`). This is crucial for debugging and auditing AI outputs.
    *   `CreatedByCoachId` (Guid, FK to `ApplicationUser`).

2.  **`PlayerMatchFeedback`**: Represents a single, personalized, AI-generated feedback message for a player's parent after a match.
    *   `MatchId` (Guid, required, FK to a `Match` entity).
    *   `PlayerId` (Guid, required, FK to `ApplicationUser`).
    *   `ParentId` (Guid, required, FK to `ApplicationUser`).
    *   `GeneratedMessage` (string, required): The editable message generated by the AI.
    *   `Status` (enum: `Draft`, `Reviewed`, `Sent`, `Discarded`).
    *   `CoachVoiceNoteUrl` (string, optional): A URL to the stored audio file of the coach's summary.

### Multi-Tenancy Scope

-   **`IMustHaveTenant` Required:**
    -   `TrainingSessionPlan`: Session plans are exclusive to an academy.
    -   `PlayerMatchFeedback`: Feedback is tied to players and matches within a specific academy.

### Permissions & Authorization

| FRS Role | Policy Name | Permissions Claim | Implementation Detail |
| :--- | :--- | :--- | :--- |
| `Coach` | `IsCoach` | `permission:coaching.ai.generate` | Secures the generation endpoints for session plans and feedback. |
| `Academy Director`| `IsDirector` | `permission:coaching.ai.review` | Provides read-only access to all generated content within the academy for oversight. |

## 2. Scaffolding Strategy (CLI)

Because this module is focused on content generation and review workflows rather than simple CRUD, a manual service approach is recommended. The standard scaffolding can be used to create the base entities and controllers, which will then be heavily modified.

Execute from `Diquis.Application/Services`:
```bash
# For managing saved plans (optional, as it's not the core generation logic)
dotnet new nano-service -s TrainingSessionPlan -p TrainingSessionPlans -ap Diquis
dotnet new nano-controller -s TrainingSessionPlan -p TrainingSessionPlans -ap Diquis

# For managing feedback drafts (optional, for the review/send workflow)
dotnet new nano-service -s PlayerMatchFeedback -p PlayerMatchFeedbacks -ap Diquis
dotnet new nano-controller -s PlayerMatchFeedback -p PlayerMatchFeedbacks -ap Diquis
```
**A new, manually-created `AICoachingService` will contain the core AI generation logic.**

## 3. Implementation Plan (Agile Breakdown)

### User Story: Smart Training Session Generator
**As a** Coach, **I want to** generate a structured session plan based on my team's needs and our available equipment, **so that** I can save planning time.

**Technical Tasks:**
1.  **Domain:** Create the `TrainingSessionPlan` entity in `Diquis.Domain`. Ensure it implements `BaseEntity` and `IMustHaveTenant`.
2.  **Persistence:** Add `DbSet<TrainingSessionPlan>` to `ApplicationDbContext` and create a migration.
    -   *Migration Command:* `add-migration -Context ApplicationDbContext -o Persistence/Migrations/AppDb AddAiCoachingEntities`
3.  **Application (DTOs):**
    -   `GenerateSessionPlanRequest` (`TeamId`, `Duration`, `FocusArea`, `AvailableSpace`).
    -   `SessionPlanResponse` (`Id`, `GeneratedContent`).
4.  **Application (Service):** Manually create `IAICoachingService` and `AICoachingService.cs`.
    -   Implement `GenerateSessionPlanAsync(GenerateSessionPlanRequest request)`.
    -   **Crucial:** This method must orchestrate calls to other services:
        -   Fetch team age from an existing `ITeamService`.
        -   Fetch available equipment from an existing `IInventoryService`.
    -   Construct a detailed system prompt for the AI, including the fetched context and strict constraints (e.g., "Only use the following equipment: ...").
    -   Call the AI service (e.g., `IOpenAIService`).
    -   Append the mandatory legal disclaimer to the AI's response.
    -   Save the final text as a new `TrainingSessionPlan` entity.
5.  **API:** Create a new `AICoachingController.cs`.
    -   Add a `POST /api/ai-coaching/session-plans/generate` endpoint, secured with the `IsCoach` policy.
6.  **UI (React/Client):**
    -   Create a `src/pages/training/SessionGenerator.tsx` page.
    -   The page will contain a `<SessionGeneratorForm />` with inputs for team, focus, etc.
    -   The generated plan will be displayed in an editable text area (e.g., using a Markdown editor component).

### User Story: Automated Match Report & Feedback Writer
**As a** Coach, **I want to** quickly send personalized post-match feedback to every parent, **so that** I can improve communication without spending hours writing.

**Technical Tasks:**
1.  **Domain:** Create the `PlayerMatchFeedback` entity as defined above.
2.  **Persistence:** Add `DbSet<PlayerMatchFeedback>` to the `ApplicationDbContext`. Update the migration.
3.  **Infrastructure:**
    -   An `IFileStorageService` (e.g., for Azure Blob Storage) is required to store the uploaded voice note.
    -   An `ISpeechToTextService` (e.g., Azure Cognitive Services) is required for transcription.
4.  **Application (DTOs):**
    -   `GenerateFeedbackRequest` (`MatchId`, `IFormFile CoachVoiceNote`).
    -   `PlayerFeedbackDto` (`PlayerId`, `PlayerName`, `ParentName`, `GeneratedMessage`).
5.  **Application (Service):** In `AICoachingService.cs`:
    -   Implement `GenerateAllFeedbackAsync(GenerateFeedbackRequest request)`. This is a complex orchestration method:
        1.  Upload the voice note via `IFileStorageService` and get the URL.
        2.  Transcribe the audio to text via `ISpeechToTextService`.
        3.  Fetch match participants and their key stats from `IAnalyticsService`.
        4.  Loop through each player, construct a highly-personalized AI prompt for each, and call the AI model.
        5.  Save each response as a `PlayerMatchFeedback` entity with `Status = Draft`.
    -   Implement `SendAllFeedbackAsync(Guid matchId)`:
        1.  Retrieves all `PlayerMatchFeedback` records for the match where `Status = Draft`.
        2.  Enqueues a job for each message using the existing `ICommunicationService` (Module 13).
        3.  Updates the status of each record to `Sent`.
6.  **API:** In `AICoachingController.cs`:
    -   `POST /api/ai-coaching/match-feedback/generate`: A `multipart/form-data` endpoint to accept the Match ID and voice note file. Secured by `IsCoach`.
    -   `GET /api/ai-coaching/match-feedback/{matchId}/review`: Returns a list of `PlayerFeedbackDto`s for the "Human-in-the-Loop" screen. Secured by `IsCoach`.
    -   `POST /api/ai-coaching/match-feedback/send-all`: Triggers the `SendAllFeedbackAsync` method. Secured by `IsCoach`.
7.  **UI (React/Client):**
    -   Create `src/pages/matches/{id}/GenerateFeedback.tsx`.
    -   Implement a voice recording/upload component.
    -   Create a `<FeedbackReviewList />` component that displays the generated messages.
    -   **Crucial:** Add a `ref` to the scrollable container and an `onScroll` event listener. The "Approve & Send All" button's `disabled` attribute will be tied to a state variable that is only set to `false` when the scroll position is near the bottom.

## 4. Code Specifications (Key Logic)

### `AICoachingService.cs` - Training Plan Prompt Enrichment

```csharp
// Inside AICoachingService.cs - Pseudo-code for session generation
public async Task<string> GenerateSessionPlanAsync(GenerateSessionPlanRequest request)
{
    // 1. Enrich prompt with data from other services
    var team = await _teamService.GetByIdAsync(request.TeamId);
    var equipment = await _inventoryService.GetAvailableEquipmentAsync(); // Returns List<InventoryItemDto>

    var equipmentList = equipment.Where(e => e.Quantity > 0).Select(e => $"{e.Name} ({e.Quantity})");
    string availableEquipment = string.Join(", ", equipmentList);

    // 2. Construct the detailed system prompt
    string systemPrompt = $"You are an expert youth football coach AI. Generate a {request.Duration}-minute training plan.    
    **CONSTRAINTS:**
    - The team's age group is {team.AgeGroup}. All drills must be appropriate for this level.
    - You may ONLY use the following available equipment: {availableEquipment}. Do not suggest drills using any other equipment.
    - The focus of the session is: {request.FocusArea}.
    - The available space is: {request.AvailableSpace}.

    Format the output as a timeline (e.g., 0-15 mins, 15-40 mins, etc.)";

    // 3. Call AI model
    var aiResponse = await _aiModelService.GetCompletionAsync(systemPrompt);

    // 4. Append disclaimer and save
    const string disclaimer = "\n\n**Disclaimer:** This is an AI-generated plan. The coach is solely responsible for the physical safety, well-being, and appropriate supervision of all players during the session.";
    
    string finalContent = aiResponse + disclaimer;
    
    // ... save new TrainingSessionPlan entity ...

    return finalContent;
}
```

### `AICoachingService.cs` - Personalized Feedback Prompt Loop

```csharp
// Inside AICoachingService.cs - Pseudo-code for feedback generation loop
public async Task GenerateAllFeedbackAsync(Guid matchId, string voiceTranscript)
{
    var playerStats = await _analyticsService.GetPlayerStatsForMatchAsync(matchId); // List of { PlayerId, Name, ParentName, Stat1, Stat2 }

    foreach (var player in playerStats)
    {
        string playerPrompt = $"You are a helpful assistant coach. Your tone is positive and encouraging.        
        Use the following information to write a short, personalized feedback paragraph for {player.Name}'s parent, {player.ParentName}.
        
        - Coach's general thoughts from voice note: \"{voiceTranscript}\"        - Player's standout contribution: Scored {player.Goals} goals.        - Overall match result: We won 3-1.        
        Combine these points into a natural-sounding message. Start with 'Hi {player.ParentName},'.";

        var personalizedMessage = await _aiModelService.GetCompletionAsync(playerPrompt);

        // Save this message to the PlayerMatchFeedback table with Status = Draft
        var feedbackDraft = new PlayerMatchFeedback
        {
            MatchId = matchId,
            PlayerId = player.PlayerId,
            ParentId = player.ParentId,
            GeneratedMessage = personalizedMessage,
            Status = FeedbackStatus.Draft
        };
        await _feedbackRepo.AddAsync(feedbackDraft);
    }
}
```

### React UI - "Human-in-the-Loop" Button Logic

```typescript
// In src/components/FeedbackReviewList.tsx
import React, { useState, useRef } from 'react';

export const FeedbackReviewList = ({ feedbackItems }) => {
    const [canSend, setCanSend] = useState(false);
    const scrollContainerRef = useRef<HTMLDivElement>(null);

    const handleScroll = () => {
        const container = scrollContainerRef.current;
        if (container) {
            // Check if user has scrolled to the bottom (with a 10px tolerance)
            const isAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 10;
            if (isAtBottom && !canSend) {
                setCanSend(true);
            }
        }
    };

    const handleSendAll = () => {
        // API call to POST /api/ai-coaching/match-feedback/send-all
        console.log("Sending all messages...");
    };

    return (
        <div>
            <div ref={scrollContainerRef} onScroll={handleScroll} style={{ height: '500px', overflowY: 'scroll' }}>
                {/* {feedbackItems.map(item => <div key={item.playerId}>{...}</div>)} */}
            </div>
            
            <button onClick={handleSendAll} disabled={!canSend}>
                Approve & Send All
            </button>
        </div>
    );
};
```